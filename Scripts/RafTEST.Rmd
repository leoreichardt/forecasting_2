---
title: "RafTEST"
author: "Raffaello Raffin"
date: "4/28/2020"
output: html_document
---

```{r libraries, include=FALSE}
library(readr)
library(hts)
library(stringi)
library(dplyr)
library(stringr)
library(purrr)
library(tidyr)
```


```{r}
# Load data
df <- read_csv("~/Documents/GitHub/forecasting_2/Data/sales_train_validation.csv")
df <- data.frame(df, stringsAsFactors = FALSE)
df <- within(df, 
             item_id <- as.factor(item_id),
             dept_id <- as.factor(dept_id),
             cat_id <- as.factor(cat_id))
cal <- read.csv("~/Documents/GitHub/forecasting_2/Data/calendar.csv", na.strings = "")
prices <- read_csv("~/Documents/GitHub/forecasting_2/Data/sell_prices.csv")
prices <- data.frame(prices, stringsAsFactors = FALSE)
```


```{r}
# Subset to a specific store
df <- subset(df, store_id == "TX_1")
 
# Take only the sales columns and transpose them
tdf <- t(df[,7:ncol(df)])

# Add "NA" values for the validation days;
# Could also drop the extra columns from from `cal`
tdf2 <- rbind(tdf, 
              matrix(NA, nrow = nrow(cal) - nrow(tdf),
                     ncol = ncol(tdf)))
tdf3 <- data.frame(cbind(cal, tdf2))

# Add in the unique names for each column
colnames(tdf3) <- c(colnames(tdf3)[1:14], df$id)
```


```{r}
# Add price information: 
# 1) Reshape the price data to have time series in rows, not columns
# 2) Since the prices are given per week, repeat them accordingly to 
#    get a full time series
# 3) For those prices which are absent at the beginning of the data,
#    we fill the missing values with the first observed price.

# 1)
prices <- subset(prices, store_id == "TX_1") %>% select(-store_id,) %>%
  spread(item_id, sell_price)
colnames(prices) <- c("wm_yr_wk", paste0("PRICE_", colnames(prices)[-1]))

# 2)
repetitions <- table(tdf3$wm_yr_wk)
prices_full <- data.frame(wm_yr_wk = rep(prices$wm_yr_wk, times = repetitions))
for (j in 2:ncol(prices))
  prices_full <- cbind(prices_full, rep(prices[,j], times = repetitions))
colnames(prices_full) <- colnames(prices)

# 3)
are_na_at_beginning <- is.na(prices_full[1,])
for (j in which(are_na_at_beginning)) {
  first_non_na <- which(!is.na(prices_full[,j]))[1]
  prices_full[1:first_non_na,j] <- prices_full[first_non_na, j]
}
```


```{r}
# Finally, combine all the data (volume + calendar + prices)
tdf4 <- merge(tdf3, prices_full, by = "wm_yr_wk")
```


```{r}
# In the following, we discard the price part and work only with the volume data.

# When using `hts`, we first need to create a multivariate time series object;
# for this we discard several calendar columns which are redundant.
TX1 <- ts(tdf3[,-(1:14)], start = c(2011, 29), end = c(2016, 116), frequency = 365)
```


```{r}
# Next we have to create a way of denoting which series is nested in another.
# This is done by supplying the `bnames` argument to hts(), and here 
# we create the corresponding names by truncating the category names to 3 letters.

# 1) Separate out the parts in the id column
splitted <- do.call(rbind, stri_split_fixed(df$id, '_'))[,1:5]
# 2) Normalise the category names
splitted[,1] <- substr(splitted[,1], 1, 3)
hts_ids <- apply(splitted, 1, paste0, collapse = '')
```


```{r}
# Create the hts object by specifying which parts of the series name correspond
# to which level of the hierarchy
TX1.h <- hts(TX1, bnames = hts_ids, characters = c(3,1,6))
```


```{r}
#we keep only 3 levels
hts_ids_level0_1 <- str_sub(hts_ids, end = 4) %>% unique()
  
lvl0_1 <- TX1.h %>% aggts(levels=0:2)

TX1_lvl0_1 <- hts(lvl0_1, bnames = hts_ids_level0_1, characters = c(3,1))
```


```{r}
# Create training and validation set
training_set <- window(TX1_lvl0_1, start = c(2011, 29), end = c(2016, 60))
validation_set <- window(TX1_lvl0_1, start = c(2016, 61), end = c(2016, 88)) 
all <- window(TX1_lvl0_1, start = c(2011, 29), end = c(2016, 88))
```


# Forecast

```{r}
#forecast
f1 <- forecast(training_set, h = 28, method = "bu", fmethod = "arima")

# To get the accuracy measures:
acc <- accuracy.gts(f1, validation_set)
View(acc)
#RMSE 1358.87

f1 %>% 
  aggts(levels = 0) %>%
  checkresiduals()


#objectif: trouver des plots sympa
library(ggplot2)
plot(f1, levels = 0, include = 30) 

 autoplot(aggts(validation_set, level=0)) +
  autolayer(aggts(f1, level=0), lty=2) +
   theme_bw() #du lourd
 
 
f1 %>% aggts(levels = 0) %>% ts(frequency = 365) %>% autoplot()
```

```{r}
#forecast
f7 <- forecast(training_set, h = 28, method = "bu", fmethod = "ets")

# To get the accuracy measures:
a7 <- accuracy.gts(f7, validation_set)
View(a7)
#RMSE 1502

f7 %>% 
  aggts(levels = 0) %>%
  checkresiduals()

 autoplot(aggts(validation_set, level=0)) +
  autolayer(aggts(f7, level=0), lty=2) +
   theme_bw()
```


```{r}
#change frequency
TX1B <- ts(tdf3[,-(1:14)], frequency = 7)

training_setb <- TX1B[1:1857,]  
validation_setb <- TX1B[1858:1885,]

#get hts id
splitted <- do.call(rbind, stri_split_fixed(df$id, '_'))[,1:5]
splitted[,1] <- substr(splitted[,1], 1, 3)
hts_ids <- apply(splitted, 1, paste0, collapse = '')

#training set
hts_train_b <- hts(training_setb, bnames = hts_ids, characters = c(3,1,6))
lvl0_1b <- hts_train_b %>% aggts(levels=0:2)
hts_ids_level0_1b <- str_sub(hts_ids, end = 4) %>% unique()
hts_trainb01 <- hts(lvl0_1b, bnames = hts_ids_level0_1b, characters = c(3,1))

#validation set
hts_val_b <- hts(validation_setb, bnames = hts_ids, characters = c(3,1,6))
lvl0_1b_val <- hts_val_b %>% aggts(levels=0:2)
hts_ids_level0_1b <- str_sub(hts_ids, end = 4) %>% unique()
hts_valb01 <- hts(lvl0_1b_val, bnames = hts_ids_level0_1b, characters = c(3,1))
```

```{r}
#forecast
f2 <- forecast(hts_trainb01, h = 28, method = "comb", weights = "mint", covariance = "shr")

# To get the accuracy measures:
a2 <- accuracy.gts(f2, hts_valb01)
View(a2)
#RMSE 1502

f2 %>% 
  aggts(levels = 0) %>%
  checkresiduals()

plot(f2, include = 90, levels = 0) 
```

```{r}
#forecast
f3 <- forecast(hts_trainb01, h = 28, method = "bu", fmethod = "ets")

# To get the accuracy measures:
a3 <- accuracy.gts(f3, hts_valb01)
View(a3)
#RMSE 1508

f3 %>% 
  aggts(levels = 0) %>%
  checkresiduals()

plot(f3, include=90, levels = 0)
```

```{r}
training_set3 <- window(TX1.h, start = c(2011, 29), end = c(2016, 60))
validation_set3 <- window(TX1.h, start = c(2016, 61), end = c(2016, 88)) 

#forecast
f10 <- forecast(training_set3, h = 28, method = "bu", fmethod = "arima")


```


















```{r}
#forecast
TX1.fc5 <- forecast(training_set, h = 28, method = "tdfp", fmethod = "ets")

#doesn't work with frequ more than 24

# To get the accuracy measures:
acc5 <- accuracy.gts(TX1.fc5, validation_set)
View(acc5)

#RMSE 429 with frequ 12

plot(TX1.fc5, include = 120, levels = 0)
```


#### Bottom-up approach

```{r}
#forecast
TX1.fc <- forecast(training_set, h = 28, method = "bu", fmethod = "rw")

# To get the accuracy measures:
acc <- accuracy.gts(TX1.fc, validation_set)
View(acc)

#RMSE 908

plot(TX1.fc, include = 90, levels = 0)
```












#### Comb approach


```{r}
#forecast
TX1.fc3 <- forecast(training_set2, h = 1, method = "comb", weights = "mint", covariance = "shr")

# I can't handle data with frequency greater than 24. Seasonality will be ignored. Try stlf() if you need seasonal forecasts. (error message)

#Error in if (!is.symmetric.matrix(x)) stop("argument x is not a symmetric matrix") : missing value where TRUE/FALSE needed

# To get the accuracy measures:
acc3 <- accuracy.gts(TX1.fc3, validation_set2)
View(acc3)

plot(TX1.fc3, include = 90, levels = 0) 
```


## Some plots

```{r}
TX1.h %>% aggts(levels=0:1) %>%
  autoplot(facet=TRUE) 
```


```{r}
TX1.h %>% aggts(levels=1:2) %>%
  autoplot(facet=TRUE) 
```


```{r}
aggts1 <- aggts(TX1.h)
aggts2 <- aggts(TX1.h, levels = 1)
aggts3 <- aggts(TX1.h, levels = c(0, 2))
plot(TX1.h, levels = 1)
```






