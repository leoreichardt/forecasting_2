---
title: "forecast2"
output: html_document
---
```{r setup, include=FALSE}
rm(list=ls())
library(hts)
library(stringi)
library(dplyr)
library(stringr)
library(purrr)
library(tidyr)
library(lubridate)
library(knitr)
library(ggplot2)

# Load data
df <- read.csv('~/Desktop/4.2/forecasting/m5-forecasting-accuracy/sales_train_validation.csv', stringsAsFactors = FALSE)
df <- within(df, 
             item_id <- as.factor(item_id),
             dept_id <- as.factor(dept_id),
             cat_id <- as.factor(cat_id))
cal <- read.csv('~/Desktop/4.2/forecasting/m5-forecasting-accuracy/calendar.csv', na.strings = "")
prices <- read.csv('~/Desktop/4.2/forecasting/m5-forecasting-accuracy/sell_prices.csv', stringsAsFactors = FALSE)

# Subset to a specific store
df <- subset(df, store_id == "TX_1")

# Take only the sales columns and transpose them
tdf <- t(df[,7:ncol(df)])

# Add "NA" values for the validation days;
# Could also drop the extra columns from from `cal`
tdf2 <- rbind(tdf, 
              matrix(NA, nrow = nrow(cal) - nrow(tdf),
                     ncol = ncol(tdf)))
tdf3 <- data.frame(cbind(cal, tdf2))

# Add in the unique names for each column
colnames(tdf3) <- c(colnames(tdf3)[1:14], df$id)

# Add price information: 
# 1) Reshape the price data to have time series in rows, not columns
# 2) Since the prices are given per week, repeat them accordingly to 
#    get a full time series
# 3) For those prices which are absent at the beginning of the data,
#    we fill the missing values with the first observed price.

# 1)
prices <- subset(prices, store_id == "TX_1") %>% select(-store_id,) %>%
  spread(item_id, sell_price)
colnames(prices) <- c("wm_yr_wk", paste0("PRICE_", colnames(prices)[-1]))

# 2)
repetitions <- table(tdf3$wm_yr_wk)
prices_full <- data.frame(wm_yr_wk = rep(prices$wm_yr_wk, times = repetitions))
for (j in 2:ncol(prices))
  prices_full <- cbind(prices_full, rep(prices[,j], times = repetitions))
colnames(prices_full) <- colnames(prices)

# 3)
are_na_at_beginning <- is.na(prices_full[1,])
for (j in which(are_na_at_beginning)) {
  first_non_na <- which(!is.na(prices_full[,j]))[1]
  prices_full[1:first_non_na,j] <- prices_full[first_non_na, j]
}

# Finally, combine all the data (volume + calendar + prices)
tdf4 <- merge(tdf3, prices_full, by = "wm_yr_wk")

```

creating a new data frame with sales per day
```{r echo=FALSE}

ventes <- as.numeric()
for (i in 7:ncol(df)) {
  ventes[i] <- sum(df[ ,i])
}
ventes <- ventes[-c(1:6)]

## créer un vecteur correspondant à d_1 à d_1913
dates <- seq(as.Date("2011-01-29"), as.Date("2016-04-24"), by="days")

ventes_et_dates <- data.frame(ventes, dates)

ventes_et_dates$weekday = weekdays(ventes_et_dates$dates)
ventes_et_dates$month = month(ventes_et_dates$dates)
```

number of product per departement
```{r echo=FALSE}
df %>%
  group_by(dept_id) %>%
  count() %>%
  kable()
```

sales per day for one departement (FOODS_1 in this case)
```{r echo=FALSE}
dept_group_food <- df %>%
  group_by(dept_id) %>%
  filter(dept_id=="FOODS_1")

ventes_per_dept <- as.numeric()
for (i in 7:ncol(dept_group_food)) {
  ventes_per_dept[i] <- sum(dept_group_food[ ,i])
}
ventes <- ventes[-c(1:6)]


```

average sales per weekday
```{r echo=FALSE}

ventes_et_dates$weekday <- ordered(ventes_et_dates$weekday, levels=c("Monday", "Tuesday", "Wednesday", "Thursday", 
"Friday", "Saturday", "Sunday"))

ventes_et_dates %>%
  group_by(weekday) %>%
  mutate(avg_sale = mean(ventes)) %>%
  ggplot() +
  geom_col(aes(x = weekday, y = avg_sale, color = weekday)) +
  labs(x = "Weekday", y = "Average sales", size = 10)+labs(title = "Average sales per weekday") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 10)) +
  theme(legend.position = "None")
```

average sales per month
```{r echo=FALSE}
ventes_et_dates%>%
  group_by(month)%>%
  mutate(avg_sale = mean(ventes)) %>%
  ggplot()+
  geom_col(aes(x = as.factor(month), y = avg_sale, color = month))+
  labs(x = "Month", y = "Average sales", size = 10)+labs(title = "Average sales per month") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 10))+
  theme(legend.position = "None")+
  scale_x_discrete(labels = c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"))
```

Sales per departement
```{r echo=FALSE}
df$Sales_per_product <- df %>% select(7:1919) %>% mutate() %>% rowSums()

df%>%
  group_by(dept_id)%>%
  mutate(sum_sales = sum(Sales_per_product))  %>%
  ggplot()+
  geom_col(aes(x = dept_id, y = sum_sales, color = dept_id))+
  labs(x = "departement ID", y = "Sum of sales", size = 10)+labs(title = "Sum of sales per departement") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 10)) +
  theme(legend.position = "None")
```

```{r include=FALSE}
##joining `sell_prices`and `sales_train_validation` table

#transpose the matrix
sales_calendar <- data.frame(t(df))

#create vector of date
y <- seq(as.Date("2011-01-23"), as.Date("2016-04-25"), by = "day")

#add date vector to sales_train_validation and reorder columns
sales_calendar$date <- y

sales_calendar <- sales_calendar[c(3050,1:3049)]

#join calendar and sales_train_validation
sales_calendar <- left_join(sales_calendar, cal, by = "date")
```


Max, min and average price for each product
```{r echo=FALSE}
price_TX1 <- sell_prices %>% 
  filter(store_id == "TX_1")

price_TX1 %>% 
  group_by(item_id) %>%
  summarise(max = max(sell_price), min = min(sell_price), avg = round(mean(sell_price), digits = 2)) %>%
  kable() %>% 
  kable_styling() %>%
  scroll_box(width = "100%", height = "200px")
```

Evolution of prices over time

```{r echo=FALSE}
#price avolution for one product in particular
price_TX1 %>%
  filter(item_id == "FOODS_3_794") %>% 
  ggplot(x, mapping = aes(wm_yr_wk, sell_price)) +
  geom_line() +
  labs(x = "weeks", y = "price", size = 10) +
  labs(title = "Evolution of prices over time")

#price evolution by departement
price_TX1 %>%
  mutate(category = substr(item_id, 1, 5)) %>%
  group_by(category, wm_yr_wk) %>%
  mutate(avg_price = mean(sell_price)) %>%
  ggplot() +
  geom_line(aes(wm_yr_wk, avg_price, color = category)) +
  labs(x = "weeks", y = "average prices", size = 10)+labs(title = "Evolution of prices over time by category")

```

Time serie
```{r}
tx1 <- ts(tdf3[,-(1:2)], start = c(2011, 29), end = c(2016, 170), frequency = 365)


splitted <- do.call(rbind, stri_split_fixed(df$id, '_'))[,1:5]
# 2) Normalise the category names
splitted[,1] <- substr(splitted[,1], 1, 3)
hts_ids <- apply(splitted, 1, paste0, collapse = '')

# Create the hts object by specifying which parts of the series name correspond
# to which level of the hierarchy
tx1.h <- hts(tx1, bnames = hts_ids, characters = c(3,1,6))


tx1.h %>% aggts(levels=0:1) %>%
  autoplot(facet=TRUE)
```

Total and by category
```{r}
tx1.h %>% aggts(levels=0:1) %>%
  autoplot(facet=TRUE)
```

By departement
```{r}
tx1.h %>% aggts(levels=2) %>%
  autoplot(facet=TRUE)
```

```{r}
tx1.fc <- forecast(tx1.h, h = 28, method = "bu", fmethod = "rw",
                   keep.fitted = TRUE)

eggs <- rwf(tx1, drift=TRUE, lambda=0, h=50, level=80)

autoplot(tx1) + autolayer(eggs)


  autolayer(fc, series="Simple back transformation") +
  autolayer(fc2, series="Bias adjusted", PI=FALSE) +
  guides(colour=guide_legend(title="Forecast"))
```

